# 7、Linux服务器程序规范
- 服务器程序一般以后台形式运行，后台进程又称守护进程（daemon）
- Linux服务器程序通常有一套日志系统
- Linux服务器程序一般以某个专门的非root身份运行

---

# 8、高性能服务器程序框架
服务器结构为三个主要模块：
- I/O处理单元，4种I/O模型，两种高效时间处理模式
- 逻辑单元，两种高效并发模式，高效的逻辑处理模式——有限状态机
- 存储单元 

## 8.1 服务器模型
- C/S模型
- P2P模型

## 8.2 I/O模型
阻塞的概念：阻塞I/O执行的系统调用可能因为无法立即完成而被系统挂起，知道等待的事件发生为止。
4种模型：
- 阻塞I/O      程序阻塞于读写函数
- I/O复用      程序阻塞于I/O复用系统调用，但可同时监听多个I/O事件。对I/O本身的读写操作是非阻塞的。
- SIGIO信号    信号触发读写就绪事件，用户程序执行读写操作，程序没有阻塞阶段。
- 异步I/O      内核执行读写操作并触发读写完成事件。程序没有阻塞阶段。

## 8.3 两种高效的事件处理模式
- Reactor
    - 主线程只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程。除此之外主线程不做任何其他实质性的工作。
    - 使用同步I/O模型(epoll_wait)可以实现Reactor模式
- Proactor
    - 将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。
    - 使用异步I/O模型(aio_read/aio_write)

## 8.4 两种高效的并发模式
如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。但如果程序是I/O密集型的，比如经常读写文件，访问数据库等，并发会极大提高性能。
- 半同步/半异步模式
    在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件以及该由谁来完成I/O读写（应用程序还是内核）。
    在并发模式中，“同步”指的是程序完全按照代码顺序执行，“异步”指程序的执行需要由系统事件来驱动。如中断、信号等。
    同步线程用于处理客户逻辑，异步线程用于处理I/O事件。

- 领导者/追随者模式
    多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件。
    领导者/追随者模式包含如下几个组件
        - 句柄集， 表示I/O资源
        - 线程集， 所有工作线程的管理者
        - 事件处理器
        - 具体事务处理器

## 8.6 有限状态机

## 8.7 提高服务器性能的方式
- 池化，      内存池、进程池、线程池、连接池  
- 数据复制，   两个工作进程之间需要传递大量数据时，应该考虑使用共享内存而不是使用管道或者消息队列。
- 上下文切换， 线程的数量不大于CPU的数目
- 锁

# 9、I/O复用
I/O复用使得程序能同时监听多个文件描述符，本身是阻塞的。通常，网络程序在下列情况需要使用I/O复用：
- 客户端要同时处理多个socket，比如非阻塞connect；
- 客户端要同时处理用户输入和网络连接，比如聊天室程序；
- TCP服务器要同时处理监听socet和连接socket，这是I/O复用使用最多的场合；
- 服务器要同时处理TCP请求和UDP请求；
- 服务器要同时监听多个端口，或处理多种服务。
  
实现I/O复用的系统调用主要有poll, select, epoll

## 9.1
```c
// 用      途 ：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。
// 参      数 ：
/* 
 * nfds      : 指定被监听的文件描述符的总数
 * readfds   : 可读事件对应的文件描述符集合
 * writefds  : 可写事件
 * exceptfds : 异常事件
 * timeout   : 设置select函数的超时时间
*/
#include <sys/select.h>
int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);
```

在网络编程中，下列情况socket可读：
- sokcet内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT，此时可以无阻塞的读该socket
- sokcet通信的对方关闭连接
- 监听socket上有新的连接请求
- socket上有未处理的错误

下列情况socket可写：
- sokcet内核发送缓存区中的字节数大于或等于其低水位标记SO_SNDLOWAT，此时可以无阻塞的写该socket
- socket的写操作被关闭
- socket使用非阻塞connect连接成功或者失败（超时）之后
- socket上有未处理的错误
  

## 9.2 poll调用
poll和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。
```c

#include <poll.h>
int poll(struct pollfd* fds, nfds_t nfds, int timeout);

struct pollfd {
    int fd;       // 文件描述符
    short events; // 注册的事件
    short revents; // 实际发生的事件，由内核填充
};
```
## 9.3 epoll系列系统调用

# 10 信号

# 13 多进程编程
Linux下创建新进程的系统调用是fork
```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```
